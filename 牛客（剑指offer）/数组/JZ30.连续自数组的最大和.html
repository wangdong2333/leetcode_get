<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 题目描述:
    HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:
    在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。
    但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？
    例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
    给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
    -->
    <script>
        function FindGreatestSumOfSubArray(newArr) {
            // 缓存数组的长度
            let len = newArr.length;
            // 定义一个sum，用于求和，初始值设为0
            let sum = 0;
            // 去数组的第一个值，作为最大值
            let max = newArr[0];
            // 循环数组
            for (let i = 0; i < len; i++) {
                // 把数组中的值挨个相加
                sum += newArr[i];
                // 取出max和sum中较大的一个赋值给max（三元运算符）
                max = max > sum ? max : sum;
                // 如果sum < 0，说明前面的都“不合格”，初始值恢复为0
                if (sum < 0) sum = 0;
            }
            // 返回最大值
            return max;
        }
    </script>
</body>

</html>